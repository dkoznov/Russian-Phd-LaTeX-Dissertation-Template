%% \newcommand{\ifext}[2]{\ifdefined\extflag{#1}\else{#2}\fi}
%% \newcommand{\tick}{\checkmark}%
%% \newcommand{\tickP}{\checkmark}%
%% \newcommand{\tickPP}{\checkmark}%
%% \newcommand{\xmark}{\text{\ding{55}}}
%% \newcommand{\fail}{\xmark}%
%% \newcommand\Cf{\mathit{Prog}}%\textsf{Prog}

\section*{Общая характеристика работы}

\newcommand{\actuality}{\underline{\textbf{\actualityTXT}}}
\newcommand{\progress}{\underline{\textbf{\progressTXT}}}
\newcommand{\aim}{\underline{{\textbf\aimTXT}}}
\newcommand{\tasks}{\underline{\textbf{\tasksTXT}}}
\newcommand{\novelty}{\underline{\textbf{\noveltyTXT}}}
\newcommand{\influence}{\underline{\textbf{\influenceTXT}}}
\newcommand{\methods}{\underline{\textbf{\methodsTXT}}}
\newcommand{\defpositions}{\underline{\textbf{\defpositionsTXT}}}
\newcommand{\reliability}{\underline{\textbf{\reliabilityTXT}}}
\newcommand{\probation}{\underline{\textbf{\probationTXT}}}
\newcommand{\contribution}{\underline{\textbf{\contributionTXT}}}
\newcommand{\publications}{\underline{\textbf{\publicationsTXT}}}

\input{common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам

%Диссертационная работа была выполнена при поддержке грантов ...

%\underline{\textbf{Объем и структура работы.}} Диссертация состоит из~введения, четырех глав, заключения и~приложения. Полный объем диссертации \textbf{ХХХ}~страниц текста с~\textbf{ХХ}~рисунками и~5~таблицами. Список литературы содержит \textbf{ХХX}~наименование.

%\newpage
\section*{Содержание работы}
Во \underline{\textbf{введении}} обосновывается актуальность
исследований, проводимых в рамках данной диссертационной работы,
приводится краткий обзор научной литературы по изучаемой проблеме,
формулируется цель, ставятся задачи работы, излагается научная новизна
и практическая значимость представленного исследования.

\underline{\textbf{Первая глава}} посвящена обзору области исследования.
Рассматриваются требования, предъявляемые к реалистичным моделями памяти
языков программирования, через призму наблюдаемых сценариев поведений многопоточных программ,
применяемых компиляторами оптимизаций, а также моделей памяти процессорных архитектур.
Описывается модель памяти C/C++11. Рассматриваются проблемы модели C/C++11, в том числе
проблема ,,значений из воздуха``. Приводится описание существующих 
слабых моделей памяти без ,,значений из воздуха``, в частности, ,,обещающей`` модели. 
На основе выполненного обзора были сделаны следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляция в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ,,значений из воздуха``.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ,,значений из воздуха``.
  %% \item ,,Обещающая`` модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}

\underline{\textbf{Вторая глава}} посвящена операционной  модели памяти для C/С++,
предложенной в диссертации. Модель представлена в виде операционной семантики малого шага с помощью редукционных
контекстов. Далее для обозначения упомянутой модели мы будем использовать название \OpCpp.

Основное отличие слабых моделей памяти от модели последовательной консистентности заключается в том, что
слабые модели не гарантируют для локации в памяти единственность значения, которое может быть прочитано из локации
в каждый конкретный момент времени.
Так, например, следующая программа может завершиться с $a = 1, b = 0$, хотя, казалось бы, $a = 1$ гарантирует, что
в локацию $d$ уже записано новое значение $239$:
\[
\begin{array}{c}
[f] := 0; [d] := 0; \\
\begin{array}{l||l}
  {} [d] := 239; & a := [f]; \\
  {} [f] := 1;   & b := [d]; \\
\end{array}
\end{array}
\]
Как следствие, оперативная память (далее просто ,,память``) не может быть представлена как функция из локации в значения в рамках слабых моделей памяти.

Память в модели $\OpCpp$ представляется как множество \emph{сообщений}. Каждое сообщение содержит целевую локацию, записываемое значение и
\emph{метку времени} --- натуральное число, которое определяет полный порядок на сообщениях, относящихся к одной локации.
Последнее нужно для того, чтобы гарантировать последовательную консистентность для программ, оперирующих только над одной локацией --- эту гарантию
предоставляют большинство слабых моделей памяти, в том числе модель C/C++11.
При выполнении инструкции чтения из некоторой локации поток может недетерминированно выбрать сообщение, относящееся к локации, и произвести
чтение.

%% Представление памяти как множества сообщений позволяет симулировать исполнение приведенной выше программы, которое заканчивается результатом
%% $a = 1, b = 0$, следующим образом. После выполнения Сначала левый поток выполняет 

Недетерминированность чтения из локации ограничена гарантией, которую также предоставляет модель C/C++11: 
после того, как поток прочитал или записал сообщение в локацию $x$ с меткой времени $t$, он (поток) больше не может читать из множества сообщений
с меткой времени, которая меньше $t$. Для реализации данного ограничения в модели $\OpCpp$ у каждого потока есть т.н. \emph{базовый фронт}
(current view, current viewfront) --- функция из локаций в метки времени, определяющая осведомленность потока о сообщениях в памяти.

Некоторые программы имеют такие слабые исполнения, разрешенные моделью C/C++11, которые не могут быть промоделированы лишь недетерминированной
памятью, а дополнительно требуют исполнения инструкций не по порядку. Например, следующая программа может завершиться с
результатом $a = 1, b = 1$ в модели C/C++11:
\[
\begin{array}{c}
[x] := 0; [y] := 0; \\
\begin{array}{l||l}
  {} a := [x]; & b := [y]; \\
  {} [y] := 1; & [x] := 1; \\
\end{array}
\end{array}
\]
Для представления таких сценариев исполнения в модели $\OpCpp$ у каждого потока есть \emph{буфер отложенных операций}. Так, модель
позволяет потоку в каждый момент исполнения отложить текущую операцию вместо её выполнения.
С помощью этого механизма модель $\OpCpp$ может исполнить приведенную выше программу и получить результат $a = 1, b = 1$ следующим образом.
Сначала левый поток откладывает чтение из локации $x$ и выполняет запись в $y$. После этого правый поток читает из вновь добавленного
сообщения и записывает $1$ в $x$. Теперь левый поток исполняет отложенное чтение и читает из добавленного правым потоком сообщения, получая
$a = 1, b = 1$.

Для поддержки высвобождающих (release) барьеров и записей, а также  приобретающих (acquire) барьеров и чтений
модель $\OpCpp$ использует дополнительные фронты --- высвобождающий и приобретающий для каждого потока,
а также фронт сообщений у каждого сообщения в памяти. Для поддержки чтений с модификатором доступа
consume модель использует динамическую синтаксическую пометку зависимых от consume-чтения инструкций.

%% Рассмотрим следующую программу, в которой левый поток передает сообщение через локацию $d$ в правый поток:
%% \[
%% \begin{array}{c}
%% [f] := 0; [d] := 0; \\
%% \begin{array}{l||l}
%%   {} [d] := 239; & a := [f]; \\
%%   {} [f] := 1;   & b := [d]; \\
%% \end{array}
%% \end{array}
%% \]
%% Здесь локация $f$ используется как индекс того, что левый поток уже записал нужные данные в локацию $d$.
%% В рамках модели последовательной консистентности гарантируется, что если $a = 1$, т.е. правый поток
%% ,,увидел`` запись в $f$, то дальше он прочитает из записи в $d$, сделанной левым потоком, и в результате $b$ будет
%% равняться $239$. Это гарантируется тем, что 

Для модели был реализован интерпретатор на языке Racket с помощью библиотеки описания редукционных
семантик PLT/Redex. Код проекта доступен по адресу \url{github.com/anlun/OperationalSemanticsC11}.

Апробация предложенной семантики была выполнена на наборе из более чем 40 программ-тестов (litmus tests) из тематической литературы, а также 
на  алгоритме RCU (Read-Copy-Update). Поведение модели $\OpCpp$ совпадает с поведением модели C/C++11 на большинстве этих тестов.
Отличия наблюдаются на двух категориях тестов. Первая категория --- это программы, которые имеют исполнения со
,,значениями из воздуха`` в рамках модели C/C++11. Для таких тестов модель $\OpCpp$ не выдает исполнения со ,,значениями из воздуха``,
что является её положительным свойством. Вторая категория --- это программы, в которых существуют антизависимости по управлению,
адресу или значению, ведущие к инструкциям записи. На таких программах $\OpCpp$ не способна получить все возможные в рамках C/C++11
исполнения, поскольку выполнение инструкций не по порядку в $\OpCpp$ реализовано в ней синтаксическим способом. Этот недостаток модели не позволяет поддержать все необходимые компиляторные оптимизации.

Одновременно с моделью памяти $\OpCpp$, исследователями Kang, Hur, Lahav, Vafeiadis и Dreyer была представлена ,,обещающая`` модель
памяти, которая очень близка $\OpCpp$, но использует другой механизм для выполнения инструкций не по порядку, позволяющий
поддержать большее число компиляторных оптимизаций, чем модель $\OpCpp$.
Из-за данного преимущества диссертант принял решение продолжить свою исследовательскую работу в рамках ,,обещающей`` модели.

%% {
%% %% \setlength{\belowcaptionskip}{-20pt} 
%% \begin{figure}[h!]
%% \centering
%% {\scriptsize
%% %% \begin{tabular}{| l ||@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}||@{~}c@{~}|}
%% \begin{tabular}{| l ||@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}|@{~}c@{~}||@{~}c@{~}|}
%%   \hline
%%   \textbf{Название теста} & \textsf{VF} & \textsf{WF} & \textsf{SCF}
%%   & \textsf{NAF} & \textsf{PO} & \textsf{ARR} % & \textsf{VS}
%%   & \textsf{CR} & \textsf{JN} & \textbf{C11} \\
%% %
%% % \textbf{Test name} & History & Viewfronts & Write-fronts & SC-front
%% %           & NA-front & Postponed operations & Acquire Read Restrictions (& Value Stealing) & Consume & Joining threads w/ non-empty operation buffers & \textbf{Full Support} \\

%% \hline\hline
%% \multicolumn{10}{|c|}{Store Buffering (\textsf{SB})\ifext{, \S\ref{app:sb}}{}} \\
%% \hline
%% \textsf{rel+acq}   & \tick & &       & & & & & & \tick\\ 
%% \textsf{sc}        & \tick & & \tick & & & & & & \tick\\ 
%% \textsf{sc+rel}    & \tick & & \tick & & & & & & \tick\\ 
%% \textsf{sc+acq}    & \tick & & \tick & & & & & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Load Buffering (\textsf{LB})\ifext{, \S\ref{app:lb}}{}} \\
%% \hline
%% \textsf{rlx}         & \tick & & & & \tick & & & & \tick\\ 
%% \textsf{rel+rlx}     & \tick & & & & \tick & & & & \tick\\ 
%% \textsf{acq+rlx}     & \tick & & & & \tick & & & & \fail\\ 
%% \textsf{rel+acq+rlx} & \tick & & & & \tick & \tick & & & \tick\\ 
%% \textsf{rlx+use}     & \tick & & & & \tick & & & & \tick\\ 
%% \textsf{rlx+let}     & \tick & & & & \tick & & & & \tick\\ 
%% \textsf{rlx+join}    & \tick & & & & \tick & & & \tick & \tickP\\ 
%% \textsf{rel+rlx+join} & \tick & & & & \tick & & & \tick & \tickP\\ 
%% \textsf{acq+rlx+join} & \tick & & & & \tick & & & \tick & \fail\\ 

%% \hline
%% \multicolumn{10}{|c|}{Message passing (\textsf{MP})\ifext{, \S\ref{app:mp}}{}} \\
%% \hline
%% \textsf{rlx+na}            & \tick &       & & \tick & & &       & & \tick\\ 
%% \textsf{rel+rlx+na}        & \tick &       & & \tick & & &       & & \tick\\ 
%% \textsf{rlx+acq+na}        & \tick &       & & \tick & & &       & & \tick\\ 
%% \textsf{rel+acq+na}        & \tick &       & & \tick & & \tick & & & \tick\\ 
%% \textsf{rel+acq+na+rlx(\_2)} & \tick & \tick & & \tick & & \tick & & & \tick\\ 
%% \textsf{con+na(\_2)}       & \tick &       & & \tick & & & \tick & & \tick\\ 
%% \textsf{cas+rel+acq+na}    & \tick &       & & \tick & & \tick & & & \tick\\ 
%% \textsf{cas+rel+rlx+na}    & \tick &       & & \tick & & &     & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Coherence of Read-Read (\textsf{CoRR})\ifext{, \S\ref{app:corr}}{}} \\
%% \hline
%% \textsf{rlx}      & \tick & &       & & &  & & & \tick\\ 
%% \textsf{rel+acq}  & \tick & &       & & &  & & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Independent Reads of Independent Writes (\textsf{IRIW})\ifext{, \S\ref{app:iriw}}{}} \\
%% \hline
%% \textsf{rlx}      & \tick & &       & & &  & & & \tick\\ 
%% \textsf{rel+acq}  & \tick & &       & & &  & & & \tick\\ 
%% \textsf{sc}       & \tick & & \tick & & &  & & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Write-to-Read Causality (\textsf{WRC})\ifext{, \S\ref{app:wrc}}{}} \\
%% \hline
%% \textsf{rlx}      & \tick & &       & & & &  & & \tick\\ 
%% \textsf{rel+acq}  & \tick & &       & & & &  & & \tick\\ 
%% \textsf{cas+rel}  & \tick & &       & & & \tick & & & \tick\\ 
%% \textsf{cas+rlx}  & \tick & &       & & & &  & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Out-of-Thin-Air (\textsf{OTA})\ifext{, \S\ref{app:ota}}{}} \\
%% \hline
%% \textsf{lb}       & \tick & &       & & \tick & & & & \fail\\ 
%% \textsf{if}       & \tick & &       & & \tick & & & & \fail\\ 

%% \hline
%% \multicolumn{10}{|c|}{Write Reorder (\textsf{WR})\ifext{, \S\ref{app:wr}}{}} \\
%% \hline
%% \textsf{rlx}      & \tick & &       & & \tick & & & & \tick\\ 
%% \textsf{rlx+rel}  & \tick & &       & & \tick & \tick & & & \tick\\ 
%% \textsf{rel}      & \tick & &       & & \tick & \tick & & & \tick\\ 

%% %% \hline
%% %% \multicolumn{11}{|c|}{Value Stealing (\textsf{VS})\ifext{, \S\ref{app:ss}}{}} \\
%% %% \hline
%% %% \textsf{rlx}      & \tick & &       & & \tick & \tick & \tick & & & \tick\\ 

%% \hline
%% \multicolumn{10}{|c|}{Speculative Execution (\textsf{SE})\ifext{, \S\ref{app:se}}{}} \\
%% \hline
%% \textsf{simple}      & \tick & &       & & \tick & & & & \tick\\ 
%% \textsf{prop}        & \tick & &       & & \tick & & & & \tick\\ 
%% \textsf{nested}      & \tick & &       & & \tick & & & & \tick\\ 

%%   \hline
%%   \multicolumn{10}{|c|}{Locks\ifext{, \S\ref{app:locks}}{}} \\
%%   \hline
%%   Dekker & \tick & & & \tick & & & & & \tick\\ 
%%   Cohen~\cite{Turon-al:OOPSLA14}  & \tick & & & \tick & & & & & \tick\\ 

%% %% LB & $\checkmark$ & & \\
%% %% \multicolumn{4}{l}{ A snippet code here
%% %% }\\
%% %% SB & $\checkmark$ & & \\

%% \hline

%% \end{tabular}
%% }
%% \caption{Litmus tests
%%   \ifext{(Appendix~\ref{sec:litmusTests})}{} and corresponding
%%   semantic aspects of our framework:
%%   {viewfronts}~(\textsf{VF},~\S\ref{sec:hist}),
%%   {write-fronts}~(\textsf{WF},~\S\ref{sec:wrf}),
%%   SC-fronts~(\textsf{SCF},~\S\ref{sec:sc}), {non-atomic
%%     fronts}~(\textsf{NAF},~\S\ref{sec:na}), {postponed
%%     operations}~(\textsf{PO},~\S\ref{sec:postponed-sem}),
%%   {acquire read restrictions}),
%%     %($\stGamma$)}~(\textsf{ARR},~\S\ref{sec:postponed-sem}),
%%   %% {value stealing}~(\textsf{VS},~\S\ref{sec:postponed-sem}),
%%   %% {if speculations}~(\textsf{IS}),
%%   {consume-reads}~(\textsf{CR}), {joining threads with non-empty
%%     operation buffers}~(\textsf{JN},~\S\ref{sec:join}).  The column
%%   \textbf{C11} indicates whether the behavior is coherent with the C11
%%   standard.  }
%% \label{fig:litmusTbl}
%% \end{figure}
%% }

В \underline{\textbf{третьей главе}} приводится описание ,,обещающей`` модели памяти и приводится
описание существующих научных задач, связанных с ней.

,,Обещающая`` модель памяти является операционной моделью памяти для синтаксиса модели C/C++11.
Она использует те же базовые понятия, что и предложенная диссертантом модель $\OpCpp$,
метки времени и фронты, однако вместо механизма откладывания выполнения инструкций ,,обещающая`` модель,
в соответствии с её названием, использует механизм \emph{обещаний}. Так, в каждый момент исполнения поток
,,обещающей`` модели памяти может выполнить одно из двух действий: либо выполнить следующую инструкцию,
либо пообещать сделать запись в локацию. Последнее может быть выполнено вне зависимости от того, какая
инструкция является следующей к выполнению в коде потока.
Если поток выбирает пообещать сделать запись в локацию, то он добавляет соответствующее сообщение в память,
делая это сообщение видимым для других потоков. Далее в ходе исполнения поток должен будет выполнить некоторую
соответствующую инструкцию записи, таким образом выполняя ранее сделанное обещание.

Для того, чтобы запретить ,,значения из воздуха``, после каждого шага исполнения каждый поток должен выполнить
т.н. \emph{сертификацию} --- предъявить, что он (поток) может быть локально исполнен таким образом, что
он выполнит все оставшиеся обещания. К сожалению, сертификация алгоритмически неразрешима, если
язык, для которого определена ,,обещающая`` модель, является полным по Тьюрингу. Как следствие, для
этой модели невозможно разработать интепретатор, что является её недостатком по сравнению с представленной в
диссертации модели $\OpCpp$.

Несмотря на этот недостаток, ,,обещающая`` модель обладает рядом существенных достоинств.
В частности, ,,обещающая`` модель не имеет проблемы ,,значений из воздуха``, что делает возможным разработку
выразительной программной логики для неё. Также для модели была доказана корректность существенного класса компиляторных
оптимизаций, а также корректность эффективной компиляции в модели памяти x86 и Power.

Открытой проблемой является доказательство корректности компиляции из ,,обещающей`` модели памяти в модели памяти архитектуры
ARM, которая, наравне с x86 и Power, является одной из наиболее распространённых процессорных архитектур на данный момент.
Этой задаче и посвящены последующие главы диссертации.

В \underline{\textbf{четвертой главе}} приводится описание операционной модели ARMv8 POP и приводится доказательство
корректности компиляции из подмножества ,,обещающей`` модели памяти в эту модель.
В конце главы приводятся рассуждения о том, как нужно доработать доказательство, чтобы покрыть всю ,,обещающую`` модель.

Здесь и далее под корректностью компиляции мы понимаем следующее утверждение.\\
\textbf{Определение.} Для языков $L$ и $L'$ с моделями памяти $M$ и $M'$ соответственно схема компиляции $\textsf{compile} : L \rightarrow L'$
называется \emph{корректной}, если выполняется следующее:
\[ \forall Prog \in L. \; \sembr{\textsf{compile}(Prog)}_{M'} \subseteq \sembr{Prog}_{M}, \]
где $\sembr{Prog}_{M}$ --- множество результатов сценариев поведения программы $Prog$ в модели памяти $M$.
В доказательствах корректности компиляции в ARMv8 POP и ARMv8.3 под результатом сценария поведения мы будем
понимать финальное состояние памяти.

Рассмотренное подмножество ,,обещающей`` модели памяти ($\Promise$) состоит из расслабленных (relaxed, rlx) записей и чтений,
а также высвобождающих (release, rel) и приобретающих (acquire, acq) барьеров памяти. При этом подразумевается следующая
схема компиляции:
\[
  \begin{array}{c@{~~}@{~~}l@{~~}|@{~~}l@{~~}|@{~~}l@{~~}|@{~~}l}
    \textbf{Promise:}   & [x]_{\textsf{rlx}} := \; a & a := [x]_{\textsf{rlx}}  &  \acqFence & \relFence \\[2pt]
    \textbf{ARMv8 POP:} & \writeInst{x}{a}    & \readInst{a}{x}  &  \dmbLD & \dmbSY \\
  \end{array}
\]
Первый и второй столбцы подразумевают, что расслабленные записи и чтения из языка, на котором определена ,,обещающая`` модель,
переходят в обычные записи и чтения в терминах ARMv8-ассемблера, а приобретающий и высвобождающий барьеры --- в барьер
по чтению и в полный барьер. Такая схема компиляции считается эффективной и применяется в компиляторах GCC и LLVM.
Поскольку схема компиляции в данном случае является биекцией, то далее в этой главе мы предполагаем, что язык задания ,,обещающей`` и ARMv8 POP
моделей совпадает.

Основной результат главы %про корректность компиляции из ,,обещающей`` семантики в ARMv8 POP
сформулирован следующим образом. \\
\emph{Теорема 3.1.} Для любых программы $\Cf$ из языка задания модели и её сценария поведения в модели ARMv8 POP существует
такой сценарий поведения $\Cf$ в ,,обещающей`` модели, что финальное состояние памяти в сценариях поведения совпадает.

В рамках доказательства теоремы нужно построить сценарий поведения в ,,обещающей`` модели по сценарию поведения в модели ARMv8 POP.
Поскольку обе модели заданы операционно, то существуют две абстрактные машины, которые представляют данные модели.
Стандартным методом для решения задачи построения исполнения одной машины по исполнению другой машины является техника симуляции,
которая является специализированной формой индукции. В рамках данной техники предполагается введение отношения симуляции,
которое связывает состояния машин, и доказательство двух лемм. Во-первых, что отношение связывает начальные состояния машин (база индукции).
Во-вторых, что для любого шага симулируемой машины существует ноль или более шагов симулирующей машины, таких что
новые состояния машин опять связаны отношением симуляции (индукционный переход).

%% Модель памяти ARMv8 POP --- операционная модель памяти для архитектуры ARMv8.0, предложенная в 2016 г.
%% Данная модель определена в терминах, достаточно близких к физической реализации архитектуры ARM.
%% Абстрактная машина, которая реализует модель ARMv8 POP, состоит из двух компонент: подсистем памяти и управления.

%% Подсистема памяти является иерархической структурой \emph{буферов}, каждый из которых является списком запросов к подсистеме.
%% Запросом, при этом, может быть чтение из локации, запись в локацию или барьер памяти.
%% Идейно подсистема памяти похожа на иерархическую систему кэшей, используемую в современных процессорах.
%% Так, подсистема управления может послать запрос в подсистему хранения. В таком случае запрос сначала попадает в буфер, который локален
%% для соответствующего потока, потом он может быть передан следующему в иерархии буферу, который является общий для некоторого
%% набора потоков, и так далее, пока запрос не попадёт в основную память или, если это запрос на чтение, не будет
%% удовлетворён из сообщения.

%% Подсистема управления выполняет программу каждого потока. Шагом исполнения программы потока является полное или частичное исполнение
%% некоторой инструкции из потока. Например, исполнение инструкции чтения выполняется в три шага --- отправка запроса в подсистему памяти,
%% получение ответа от подсистемы памяти и завершение исполнения инструкции чтения. При этом между упомянутыми шагами исполнения могут
%% исполняться другие инструкции, поскольку подсистема управления может исполнять инструкции не по порядку и спекулятивно.

Сложностью в доказательстве индукционного перехода является то, что между моделями существует два существенных различия.
Во-первых, ,,обещающая`` модель может исполнять не по порядку только инструкции записи, что соответствует механизму обещаний в ней,
тогда как модель ARMv8 POP может исполнять инструкции в несколько шагов, не по порядку и спекулятивно.
Во-вторых, в ,,обещающей`` модели в тот момент, когда сообщение попадает в память, этому сообщению присваивается некоторая
метка времени, которая служит его порядковым номером среди сообщений, относящихся к той же локации. В модели ARMv8 POP
меток времени нет и порядок на сообщениях к одной локации определяется не сразу после того, как
сообщения попадут в её подсистему памяти и станут видимыми для других потоков.

Для того, чтобы обойти первое различие, мы использовали технику ,,запаздывающей`` симуляции. В рамках данной техники отношение
симуляции представляется как объединение двух взаимоисключающих отношений, для конкретики $A$ и $B$. Далее индукционный
переход формулируется следующим образом. Если состояние симулируемой машины $x$ связано с состояние симулирующей машины $y$ отношением $A$,
т.е. выполняется $(x,y) \in A$, то для любого состояния $x'$, в которое может перейти симулируемая машина, выполняется $(x', y) \in A \cup B$.
С другой стороны, если $(x, y) \in B$, то существует такое состояние $y'$, в которое может перейти симулирующая машина, что $(x, y') \in A \cup B$.
При условии, что не существует такой бесконечной цепочки $\{y'_i\}_{i \in \mathbb{N}}$, что $y'_i$ переходит $y'_{i+1}$ и $(x, y'_i) \in B$ для всех $i$,
то из нового варианта индукционного перехода следует изначальное утверждение симуляции.

В доказательстве теоремы 3.1 отношение $A$ символизирует, что ,,обещающая`` машина ждёт, пока ARM-машина выполнит действие, которое ,,обещающая``
машина может повторить, тогда как отношение $B$ --- что ,,обещающая`` машина может симулировать несколько действий, уже выполненных ARM-машиной.

Для того, чтобы обойти второе различие между ,,обещающей`` и ARMv8 POP моделями, в доказательстве вводится ограниченная версия ARM-машины,
которая добавляет метки времени к сообщениям записи в подсистеме памяти, тем самым определяя порядок на сообщениях к одной локации
раньше, чем это делает обычная ARMv8 POP модель. Это изменение также добавляет дополнительные ограничения на сценарии поведения ARM-машины.
Тем не менее, мы доказываем, что новая модель эквивалентна изначальной, что позволяет свести доказательство теоремы 3.1
к доказательству корректности компиляции из ,,обещающей`` в модифицированную ARMv8 POP модели.

В \underline{\textbf{пятой главе}} обсуждается аксиоматическая модель памяти ARMv8.3.
Приводятся рассуждения о том, почему метод доказательства корректности компиляции из
,,обещающей`` модели памяти, использованный её авторами для случая аксиоматических моделей архитектур x86 и Power,
не подходит для модели ARMv8.3. Далее приводится доказательство корректности компиляции из ,,обещающей`` модели
памяти в подмножество модели ARMv8.3. Доказательство основано на построении операционной семантики обхода аксиоматических сценариев
поведения программ в модели ARMv8.3. В конце главы приводятся рассуждения о применимости использованного подхода для других
аксиоматических моделей.

В рамках аксиоматической (или декларативной) модели памяти сценарий поведения программы представляется как граф, в котором вершинами
являются \emph{события} (операции над памятью), а ребрами --- различные отношения на событиях, такие как программный
порядок, отношение ,,читает из`` и др. При этом граф считается согласованным с моделью, если выполняются \emph{аксиомы} модели,
которые обычно формулируются как наличие некоторого полного порядка на подмножестве событий или отсутствие путей определённого
типа в графе.

При доказательстве корректности компиляции из ,,обещающей`` модели в аксиоматическую модель техника симуляции напрямую
неприменима, поскольку сценарий поведения в аксиоматической модели не является последовательностью шагов некоторой абстрактной машины.
Поэтому в существующем доказательстве корректности компиляции в аксиоматические
модели x86 и Power авторы доказательства использовали другой метод. Этот метод состоит из двух частей.
Во-первых, доказывается, что модели x86 и Power могут быть представлены как набор программных оптимизаций поверх
более простых моделей. Эти оптимизации являются доказано корректными в рамках ,,обещающей`` модели, из чего следует,
что доказательство корректности компиляции может быть сведено к доказательству для более простых моделей.
Далее показывается, что эти более простые модели могут быть симулированы аксиоматическим аналогом
,,обещающей`` модели без механизма обещаний.

Нам не удалось применить такой подход для модели ARMv8.3, поскольку сама модель не представима как набор тех же
оптимизаций над упрощенной моделью, не требующей механизма обещаний. Поэтому мы разработали альтернативный подход,
который заключается в построении операционной семантики обхода аксиоматических построений, которая может быть
симулирована ,,обещающей`` моделью напрямую.

\emph{Обходом} мы называем последовательность переходов между \emph{конфигурациями} обхода. Конфигурацией исполнения $G$ является
упорядоченная пара подмножеств множества вершин сценария исполнения, $\tup{C, \IssuedSet}$.
Первое подмножество, $C$, называется \emph{множеством покрытых событий}, а второе, $\IssuedSet$ --- \emph{множеством выпущенных событий};
элементы этих множеств называются \emph{покрытыми} и \emph{выпущенными} соответственно.

Конфигурация обхода называется \emph{корректной}, если выполняются следующие условия.
\begin{itemize}
  \item Множество покрытых событий префикс-замкнуто относительно отношения программного порядка.
  \item Множество выпущенных событий содержит только события записи.
  \item Если событие записи покрыто, то оно и выпущено.
\end{itemize}
Интуитивно, при доказательстве симуляции ,,обещающей`` моделью обхода покрытые события будут соответствовать инструкциям, выполненным
,,обещающей`` машиной, а выпущенные события --- сообщениям в памяти ,,обещающей`` машины.

Шаги обхода задаются следующим образом:
\begin{mathpar}
\inferrule*{
    a \in \nextset(G, C) \cap \coverable(G, C, \IssuedSet) 
}{
    G \vdash 
    \tup{C, \IssuedSet} \travConfigStep \tup{C \cup \{a\}, \IssuedSet}
} \and
\inferrule*{
    w \in \issuable(G, C, \IssuedSet) \setminus \IssuedSet 
    }{
    G \vdash
    \tup{C, \IssuedSet} \travConfigStep \tup{C, \IssuedSet \cup \{w\}}
}
\end{mathpar}
Здесь первое правило соответствует покрытию события $a$, а второе --- выпуску события $w$; $\nextset(G, C)$ --- множество событий,
непосредственно следующих в отношении программного порядка за покрытыми; $\coverable(G, C, I)$ и $\issuable(G, C, I)$ ---
покрываемые и выпускаемые в текущей конфигурации события, которые определены в согласии с требованиями ,,обещающей`` модели
на исполнение инструкции и обещание сообщения соответственно.

Далее мы доказываем теорему 5.1 о полноте обхода. \\
\emph{Теорема 5.1.} Для любого корректного сценария поведения $G$ в модели ARMv8.3 существует обход
$\tup{W^{\textrm{init}}, W^{\textrm{init}}} \travConfigStep^{*} \tup{E, W}$,
где $W^{\textrm{init}}$ --- множество инициализирующих записей сценария $G$, $E$ --- все события сценария $G$,
$W$ --- все события записи сценария $G$.

Далее, используя теорему 5.1 для построения операционного исполнения программы в модели ARMv8.3,
мы доказываем, что ,,обещающая`` модель может симулировать сценарий поведения модели ARMv8.3.

%% Модель ARMv8.3 является аксиоматической, что не позволяет напрямую использовать технику симуляции для доказательства
%% корректности компиляции из ,,обещающей`` модели. 

%% В \underline{\textbf{главе}}
%% Обсуждается структура доказательства корректности компиляции. Доказательство основано на симуляции ,,обещающей`` моделью
%% памяти операционной семантики обхода исполнения программ в модели ARMv8.3.

В \underline{\textbf{заключении}} приведены основные результаты работы, которые заключаются в следующем:
\input{common/concl}

%%  картинку можно добавить так:
%% \begin{figure}[ht] 
%%   \center
%%   \includegraphics [scale=0.27] {latex}
%%   \caption{Подпись к картинке.} 
%%   \label{img:latex}
%% \end{figure}

%% Формулы в строку без номера добавляются так:
%% \[ 
%%   \lambda_{T_s} = K_x\frac{d{x}}{d{T_s}}, \qquad
%%   \lambda_{q_s} = K_x\frac{d{x}}{d{q_s}},
%% \]



%\newpage
%% При использовании пакета \verb!biblatex! список публикаций автора по теме
%% диссертации формируется в разделе <<\publications>>\ файла
%% \verb!../common/characteristic.tex!  при помощи команды \verb!\nocite! 

%% \ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=false}}{} % не рекомендуется применять пакет микротипографики к автоматически генерируемому списку литературы
%% \ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
%%   \renewcommand{\bibname}{\large \authorbibtitle}
%%   \nocite{*}
%%   \insertbiblioauthor           % Подключаем Bib-базы
%%   %\insertbiblioother   % !!! bibtex не умеет работать с несколькими библиографиями !!!
%% }{% Реализация пакетом biblatex через движок biber
%%   %% \insertbiblioauthor           % Вывод всех работ автора
%%  \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
%% %  \insertbiblioauthorimportant  % Вывод наиболее значимых работ автора (определяется в файле characteristic во второй section)
%%   \insertbiblioother            % Вывод списка литературы, на которую ссылались в тексте автореферата
%% }
%% \ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=true}}{}

\newcounter{firstbib}

\section*{\LARGE Публикации автора по теме диссертации}

Ниже приведён перечень публикаций, где были представлены основные результаты, представляемые автором в диссертации. \\

\renewcommand{\bibsection}{\noindent \textbf{\refname}}

\renewcommand{\refname}{Статьи из \vakJournals}
\begin{thebibliography}{99}
\bibitem{Podkopaev-al:NTV17} Подкопаев, А. В. О корректности компиляции подмножества обещающей модели памяти в аксиоматическую модель ARMv8.3 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Научно-технические ведомости Санкт-Петербургского государственного политехнического университета информатика, телекоммуникации, управление. ---~2017. ---~Т.~4, \textnumero~??. ---~C.~??--??.
\bibitem{Podkopaev-al:ISPRAS17} Подкопаев, А. В. Обещающая компиляция в ARMv8.3 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Труды ИСП РАН. ---~2017. ---~Т.~?, \textnumero~??. ---~C.~??--??.
\setcounter{firstbib}{\value{enumiv}}
\end{thebibliography}

\renewcommand{\refname}{Статьи в изданиях, входящих в базы цитирования Web of Science и SCOPUS}
\begin{thebibliography}{99}
\setcounter{enumiv}{\value{firstbib}}
\bibitem{Podkopaev-al:ECOOP17} Podkopaev, A. Promising compilation to ARMv8 POP / A. Podkopaev, O. Lahav, V. Vafeiadis // 31st European Conference on Object-Oriented Programming (ECOOP 17), Leibniz International Proceedings in Informatics (LIPIcs).  ---~2017. ---~P.~22:1--22:28.
\setcounter{firstbib}{\value{enumiv}}
\end{thebibliography}

\renewcommand{\refname}{Статьи в других изданиях}
\begin{thebibliography}{99}
\setcounter{enumiv}{\value{firstbib}}
\bibitem{Podkopaev-al:PLC17} Подкопаев, А. В. Обещающая компиляция в ARMv8 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Языки программирования и компиляторы. Труды конференции. Ростов-на-Дону, Россия. ---~2017. ---~C.~223--226.
\bibitem{Podkopaev-al:CoRR16} Podkopaev, A. Operational Aspects of {C/C++} Concurrency / A. Podkopaev, I. Sergey, A. Nanevski
  [Электронный ресурс]. --- URL: \url{http://arxiv.org/abs/1606.01400} (дата обращения: 14.11.2017).
\end{thebibliography}
